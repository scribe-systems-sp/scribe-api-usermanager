/* tslint:disable */
/* eslint-disable */
/**
 * UsersManager
 * Scribe user management
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKey
 */
export interface APIKey {
    /**
     * 
     * @type {string}
     * @memberof APIKey
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof APIKey
     */
    description: string;
}
/**
 * 
 * @export
 * @interface APIKeyRequest
 */
export interface APIKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof APIKeyRequest
     */
    key: string;
}
/**
 * 
 * @export
 * @interface APIKeysResponse
 */
export interface APIKeysResponse {
    /**
     * 
     * @type {Array<APIKey>}
     * @memberof APIKeysResponse
     */
    apikeys: Array<APIKey>;
}
/**
 * 
 * @export
 * @interface BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
 */
export interface BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch {
    /**
     * 
     * @type {string}
     * @memberof BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
     */
    privilegeName: string;
    /**
     * 
     * @type {string}
     * @memberof BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
 */
export interface BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyChangePasswordApiV1UsersChangePasswordPatch
 */
export interface BodyChangePasswordApiV1UsersChangePasswordPatch {
    /**
     * Password that user already has.
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    old_password: string;
    /**
     * New password
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    new_password: string;
    /**
     * Target user.
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    login: string;
}
/**
 * 
 * @export
 * @interface BodyCreateApiKeyApiV1AuthApikeysApikeyPost
 */
export interface BodyCreateApiKeyApiV1AuthApikeysApikeyPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    grant_type?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    client_secret?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    apikey_description?: string;
}
/**
 * 
 * @export
 * @interface BodyCreateUserApiV1UsersUserPost
 */
export interface BodyCreateUserApiV1UsersUserPost {
    /**
     * Login that will be used to identify user.
     * @type {string}
     * @memberof BodyCreateUserApiV1UsersUserPost
     */
    login: string;
    /**
     * Secret password that will be used for log in.
     * @type {string}
     * @memberof BodyCreateUserApiV1UsersUserPost
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete
 */
export interface BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete {
    /**
     * 
     * @type {string}
     * @memberof BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete
     */
    privilegeName: string;
}
/**
 * 
 * @export
 * @interface BodyDeleteRoleApiV1AccessrightsRolesRoleDelete
 */
export interface BodyDeleteRoleApiV1AccessrightsRolesRoleDelete {
    /**
     * 
     * @type {string}
     * @memberof BodyDeleteRoleApiV1AccessrightsRolesRoleDelete
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyLoginForAccessTokenApiV1AuthTokenPost
 */
export interface BodyLoginForAccessTokenApiV1AuthTokenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    grant_type?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    client_secret?: string;
}
/**
 * 
 * @export
 * @interface BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
 */
export interface BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch {
    /**
     * 
     * @type {string}
     * @memberof BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
     */
    privilegeName: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
 */
export interface BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyResetPasswordApiV1UsersResetPasswordPatch
 */
export interface BodyResetPasswordApiV1UsersResetPasswordPatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyResetPasswordApiV1UsersResetPasswordPatch
     */
    login: string;
}
/**
 * 
 * @export
 * @interface BodySetActiveUserApiV1UsersSetActivePatch
 */
export interface BodySetActiveUserApiV1UsersSetActivePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodySetActiveUserApiV1UsersSetActivePatch
     */
    login: string;
    /**
     * Activate or deactivate user.
     * @type {boolean}
     * @memberof BodySetActiveUserApiV1UsersSetActivePatch
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Password
 */
export interface Password {
    /**
     * 
     * @type {string}
     * @memberof Password
     */
    password: string;
}
/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Privileges
 */
export interface Privileges {
    /**
     * 
     * @type {Array<Privilege>}
     * @memberof Privileges
     */
    privileges: Array<Privilege>;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * 
     * @type {Array<Role>}
     * @memberof Roles
     */
    roles: Array<Role>;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Token
     */
    requiredScopes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type?: string;
}
/**
 * 
 * @export
 * @interface TokenStatus
 */
export interface TokenStatus {
    /**
     * 
     * @type {boolean}
     * @memberof TokenStatus
     */
    valid: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TokenStatus
     */
    scopesValid: boolean;
}
/**
 * 
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
    /**
     * 
     * @type {boolean}
     * @memberof UserStatus
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof UsersResponse
     */
    users?: Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * APIKeysApi - axios parameter creator
 * @export
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling apiV1AuthApikeysCreateApiKey.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling apiV1AuthApikeysCreateApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (apikeyDescription !== undefined) { 
                localVarFormParams.set('apikey_description', apikeyDescription as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey: async (aPIKeyRequest: APIKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyRequest' is not null or undefined
            if (aPIKeyRequest === null || aPIKeyRequest === undefined) {
                throw new RequiredError('aPIKeyRequest','Required parameter aPIKeyRequest was null or undefined when calling apiV1AuthApikeysDeleteApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aPIKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aPIKeyRequest !== undefined ? aPIKeyRequest : {}) : (aPIKeyRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/auth/apikeys/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await APIKeysApiAxiosParamCreator(configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await APIKeysApiAxiosParamCreator(configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysGetApiKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeysResponse>> {
            const localVarAxiosArgs = await APIKeysApiAxiosParamCreator(configuration).apiV1AuthApikeysGetApiKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): AxiosPromise<Token> {
            return APIKeysApiFp(configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): AxiosPromise<Token> {
            return APIKeysApiFp(configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys(options?: any): AxiosPromise<APIKeysResponse> {
            return APIKeysApiFp(configuration).apiV1AuthApikeysGetApiKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
     * @summary Create Api Key
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [apikeyDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any) {
        return APIKeysApiFp(this.configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {APIKeyRequest} aPIKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiV1AuthApikeysGetApiKeys(options?: any) {
        return APIKeysApiFp(this.configuration).apiV1AuthApikeysGetApiKeys(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRightsApi - axios parameter creator
 * @export
 */
export const AccessRightsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignPrivilege: async (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch' is not null or undefined
            if (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch === null || bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch === undefined) {
                throw new RequiredError('bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch','Required parameter bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch was null or undefined when calling apiV1AccessrightsManagingAssignPrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/assignPrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch !== undefined ? bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch : {}) : (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignRole: async (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch' is not null or undefined
            if (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch === null || bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch === undefined) {
                throw new RequiredError('bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch','Required parameter bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch was null or undefined when calling apiV1AccessrightsManagingAssignRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/assignRole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch !== undefined ? bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch : {}) : (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemovePrivilege: async (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch' is not null or undefined
            if (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch === null || bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch === undefined) {
                throw new RequiredError('bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch','Required parameter bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch was null or undefined when calling apiV1AccessrightsManagingRemovePrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/removePrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch !== undefined ? bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch : {}) : (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemoveRole: async (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch' is not null or undefined
            if (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch === null || bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch === undefined) {
                throw new RequiredError('bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch','Required parameter bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch was null or undefined when calling apiV1AccessrightsManagingRemoveRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/removeRole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch !== undefined ? bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch : {}) : (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserHasRoles: async (roles: Array<string>, login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling apiV1AccessrightsManagingUserHasRoles.');
            }
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling apiV1AccessrightsManagingUserHasRoles.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userHasRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserPrivileges: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling apiV1AccessrightsManagingUserPrivileges.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userprivileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserRoles: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling apiV1AccessrightsManagingUserRoles.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUsersWithRoles: async (roles: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling apiV1AccessrightsManagingUsersWithRoles.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/usersWithRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesCreatePrivilege: async (privilege: Privilege, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilege' is not null or undefined
            if (privilege === null || privilege === undefined) {
                throw new RequiredError('privilege','Required parameter privilege was null or undefined when calling apiV1AccessrightsPrivilegesCreatePrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/privilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof privilege !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(privilege !== undefined ? privilege : {}) : (privilege || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesDeletePrivilege: async (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete' is not null or undefined
            if (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete === null || bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete === undefined) {
                throw new RequiredError('bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete','Required parameter bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete was null or undefined when calling apiV1AccessrightsPrivilegesDeletePrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/privilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete !== undefined ? bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete : {}) : (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesGetAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesUserHasPrivilege: async (privileges?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/hasPrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (privileges) {
                localVarQueryParameter['privileges'] = privileges;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesCreateRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling apiV1AccessrightsRolesCreateRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/roles/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof role !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(role !== undefined ? role : {}) : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesDeleteRole: async (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteRoleApiV1AccessrightsRolesRoleDelete' is not null or undefined
            if (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete === null || bodyDeleteRoleApiV1AccessrightsRolesRoleDelete === undefined) {
                throw new RequiredError('bodyDeleteRoleApiV1AccessrightsRolesRoleDelete','Required parameter bodyDeleteRoleApiV1AccessrightsRolesRoleDelete was null or undefined when calling apiV1AccessrightsRolesDeleteRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/roles/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteRoleApiV1AccessrightsRolesRoleDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete !== undefined ? bodyDeleteRoleApiV1AccessrightsRolesRoleDelete : {}) : (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesGetRolePrivileges: async (roleName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling apiV1AccessrightsRolesGetRolePrivileges.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/roles/rolePrivileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/roles/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRightsApi - functional programming interface
 * @export
 */
export const AccessRightsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUserHasRoles(roles: Array<string>, login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingUserHasRoles(roles, login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUserPrivileges(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingUserPrivileges(login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUserRoles(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingUserRoles(login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUsersWithRoles(roles: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsManagingUsersWithRoles(roles, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesCreatePrivilege(privilege: Privilege, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsPrivilegesCreatePrivilege(privilege, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesGetAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsPrivilegesGetAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesUserHasPrivilege(privileges?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsPrivilegesUserHasPrivilege(privileges, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesCreateRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsRolesCreateRole(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesGetRolePrivileges(roleName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsRolesGetRolePrivileges(roleName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).apiV1AccessrightsRolesRoles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessRightsApi - factory interface
 * @export
 */
export const AccessRightsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserHasRoles(roles: Array<string>, login: string, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingUserHasRoles(roles, login, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserPrivileges(login: string, options?: any): AxiosPromise<Privileges> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingUserPrivileges(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserRoles(login: string, options?: any): AxiosPromise<Roles> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingUserRoles(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUsersWithRoles(roles: Array<string>, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsManagingUsersWithRoles(roles, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesCreatePrivilege(privilege: Privilege, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsPrivilegesCreatePrivilege(privilege, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesGetAll(options?: any): AxiosPromise<Privileges> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsPrivilegesGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesUserHasPrivilege(privileges?: Array<string>, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsPrivilegesUserHasPrivilege(privileges, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesCreateRole(role: Role, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsRolesCreateRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesGetRolePrivileges(roleName: string, options?: any): AxiosPromise<Privileges> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsRolesGetRolePrivileges(roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesRoles(options?: any): AxiosPromise<Roles> {
            return AccessRightsApiFp(configuration).apiV1AccessrightsRolesRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessRightsApi - object-oriented interface
 * @export
 * @class AccessRightsApi
 * @extends {BaseAPI}
 */
export class AccessRightsApi extends BaseAPI {
    /**
     * Assigns privilege to the role
     * @summary Assign Privilege
     * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign Role
     * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes privilege from the role
     * @summary Remove Privilege
     * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes role from the user
     * @summary Remove Role
     * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if user has specified roles
     * @summary User Has Roles
     * @param {Array<string>} roles 
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUserHasRoles(roles: Array<string>, login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUserHasRoles(roles, login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves list of all user privileges.
     * @summary User Privileges
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUserPrivileges(login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUserPrivileges(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the roles for specified user
     * @summary User Roles
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUserRoles(login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUserRoles(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users with specified roles
     * @summary Users With Roles
     * @param {Array<string>} roles 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUsersWithRoles(roles: Array<string>, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUsersWithRoles(roles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new privilege.
     * @summary Create Privilege
     * @param {Privilege} privilege 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesCreatePrivilege(privilege: Privilege, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesCreatePrivilege(privilege, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Privilege
     * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of all possible privileges
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesGetAll(options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Has Privilege
     * @param {Array<string>} [privileges] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesUserHasPrivilege(privileges?: Array<string>, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesUserHasPrivilege(privileges, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new role
     * @summary Create Role
     * @param {Role} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesCreateRole(role: Role, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesCreateRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes role
     * @summary Delete Role
     * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all privileges assigned to specified role
     * @summary Get Role Privileges
     * @param {string} roleName Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesGetRolePrivileges(roleName: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesGetRolePrivileges(roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all existed roles
     * @summary Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesRoles(options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesRoles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling apiV1AuthApikeysCreateApiKey.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling apiV1AuthApikeysCreateApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (apikeyDescription !== undefined) { 
                localVarFormParams.set('apikey_description', apikeyDescription as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey: async (aPIKeyRequest: APIKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyRequest' is not null or undefined
            if (aPIKeyRequest === null || aPIKeyRequest === undefined) {
                throw new RequiredError('aPIKeyRequest','Required parameter aPIKeyRequest was null or undefined when calling apiV1AuthApikeysDeleteApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aPIKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aPIKeyRequest !== undefined ? aPIKeyRequest : {}) : (aPIKeyRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/auth/apikeys/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthIsTokenValid: async (token: Token, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling apiV1AuthIsTokenValid.');
            }
            const localVarPath = `/usermanager/api/v1/auth/checkToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof token !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(token !== undefined ? token : {}) : (token || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLoginForAccessToken: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling apiV1AuthLoginForAccessToken.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling apiV1AuthLoginForAccessToken.');
            }
            const localVarPath = `/usermanager/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysGetApiKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeysResponse>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).apiV1AuthApikeysGetApiKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthIsTokenValid(token: Token, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenStatus>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).apiV1AuthIsTokenValid(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLoginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).apiV1AuthLoginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): AxiosPromise<Token> {
            return AuthApiFp(configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): AxiosPromise<Token> {
            return AuthApiFp(configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys(options?: any): AxiosPromise<APIKeysResponse> {
            return AuthApiFp(configuration).apiV1AuthApikeysGetApiKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthIsTokenValid(token: Token, options?: any): AxiosPromise<TokenStatus> {
            return AuthApiFp(configuration).apiV1AuthIsTokenValid(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLoginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return AuthApiFp(configuration).apiV1AuthLoginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
     * @summary Create Api Key
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [apikeyDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {APIKeyRequest} aPIKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthApikeysGetApiKeys(options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthApikeysGetApiKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Token Valid
     * @param {Token} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthIsTokenValid(token: Token, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthIsTokenValid(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthLoginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthLoginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCanIManage: async (privilegeCandidate: string, userId?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilegeCandidate' is not null or undefined
            if (privilegeCandidate === null || privilegeCandidate === undefined) {
                throw new RequiredError('privilegeCandidate','Required parameter privilegeCandidate was null or undefined when calling apiV1UsersCanIManage.');
            }
            const localVarPath = `/usermanager/api/v1/users/canIManage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (privilegeCandidate !== undefined) {
                localVarQueryParameter['privilegeCandidate'] = privilegeCandidate;
            }

            if (userId) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePassword: async (bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyChangePasswordApiV1UsersChangePasswordPatch' is not null or undefined
            if (bodyChangePasswordApiV1UsersChangePasswordPatch === null || bodyChangePasswordApiV1UsersChangePasswordPatch === undefined) {
                throw new RequiredError('bodyChangePasswordApiV1UsersChangePasswordPatch','Required parameter bodyChangePasswordApiV1UsersChangePasswordPatch was null or undefined when calling apiV1UsersChangePassword.');
            }
            const localVarPath = `/usermanager/api/v1/users/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyChangePasswordApiV1UsersChangePasswordPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyChangePasswordApiV1UsersChangePasswordPatch !== undefined ? bodyChangePasswordApiV1UsersChangePasswordPatch : {}) : (bodyChangePasswordApiV1UsersChangePasswordPatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCreateUser: async (bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserApiV1UsersUserPost' is not null or undefined
            if (bodyCreateUserApiV1UsersUserPost === null || bodyCreateUserApiV1UsersUserPost === undefined) {
                throw new RequiredError('bodyCreateUserApiV1UsersUserPost','Required parameter bodyCreateUserApiV1UsersUserPost was null or undefined when calling apiV1UsersCreateUser.');
            }
            const localVarPath = `/usermanager/api/v1/users/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateUserApiV1UsersUserPost !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateUserApiV1UsersUserPost !== undefined ? bodyCreateUserApiV1UsersUserPost : {}) : (bodyCreateUserApiV1UsersUserPost || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersGetUser: async (userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/users/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }

            if (loginSubstring !== undefined) {
                localVarQueryParameter['login_substring'] = loginSubstring;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIsUserActive: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling apiV1UsersIsUserActive.');
            }
            const localVarPath = `/usermanager/api/v1/users/isActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersResetPassword: async (bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetPasswordApiV1UsersResetPasswordPatch' is not null or undefined
            if (bodyResetPasswordApiV1UsersResetPasswordPatch === null || bodyResetPasswordApiV1UsersResetPasswordPatch === undefined) {
                throw new RequiredError('bodyResetPasswordApiV1UsersResetPasswordPatch','Required parameter bodyResetPasswordApiV1UsersResetPasswordPatch was null or undefined when calling apiV1UsersResetPassword.');
            }
            const localVarPath = `/usermanager/api/v1/users/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyResetPasswordApiV1UsersResetPasswordPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyResetPasswordApiV1UsersResetPasswordPatch !== undefined ? bodyResetPasswordApiV1UsersResetPasswordPatch : {}) : (bodyResetPasswordApiV1UsersResetPasswordPatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSetActiveUser: async (bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetActiveUserApiV1UsersSetActivePatch' is not null or undefined
            if (bodySetActiveUserApiV1UsersSetActivePatch === null || bodySetActiveUserApiV1UsersSetActivePatch === undefined) {
                throw new RequiredError('bodySetActiveUserApiV1UsersSetActivePatch','Required parameter bodySetActiveUserApiV1UsersSetActivePatch was null or undefined when calling apiV1UsersSetActiveUser.');
            }
            const localVarPath = `/usermanager/api/v1/users/setActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodySetActiveUserApiV1UsersSetActivePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodySetActiveUserApiV1UsersSetActivePatch !== undefined ? bodySetActiveUserApiV1UsersSetActivePatch : {}) : (bodySetActiveUserApiV1UsersSetActivePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersWhoCanIManage: async (privilegeCandidate: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilegeCandidate' is not null or undefined
            if (privilegeCandidate === null || privilegeCandidate === undefined) {
                throw new RequiredError('privilegeCandidate','Required parameter privilegeCandidate was null or undefined when calling apiV1UsersWhoCanIManage.');
            }
            const localVarPath = `/usermanager/api/v1/users/whoCanIManage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (privilegeCandidate !== undefined) {
                localVarQueryParameter['privilegeCandidate'] = privilegeCandidate;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersCanIManage(privilegeCandidate: string, userId?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersCanIManage(privilegeCandidate, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Password>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersGetUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersGetUser(userId, login, loginSubstring, role, active, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersIsUserActive(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStatus>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersIsUserActive(login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersWhoCanIManage(privilegeCandidate: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).apiV1UsersWhoCanIManage(privilegeCandidate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCanIManage(privilegeCandidate: string, userId?: Array<number>, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).apiV1UsersCanIManage(privilegeCandidate, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any): AxiosPromise<Password> {
            return UsersApiFp(configuration).apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersGetUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any): AxiosPromise<UsersResponse> {
            return UsersApiFp(configuration).apiV1UsersGetUser(userId, login, loginSubstring, role, active, values, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIsUserActive(login: string, options?: any): AxiosPromise<UserStatus> {
            return UsersApiFp(configuration).apiV1UsersIsUserActive(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersWhoCanIManage(privilegeCandidate: string, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).apiV1UsersWhoCanIManage(privilegeCandidate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
     * @summary Canimanage
     * @param {string} privilegeCandidate 
     * @param {Array<number>} [userId] Checks for these users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersCanIManage(privilegeCandidate: string, userId?: Array<number>, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersCanIManage(privilegeCandidate, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user password to new one
     * @summary Change Password
     * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create User
     * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {number} [userId] Get only user with specified id.
     * @param {string} [login] Return user with specified login. Login should match exactly.
     * @param {string} [loginSubstring] Return user that has in login specified substring.
     * @param {string} [role] Return user with specified role. Role should match exactly.
     * @param {boolean} [active] Return users which has provided status.
     * @param {Array<string>} [values] Only return specified fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersGetUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersGetUser(userId, login, loginSubstring, role, active, values, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns True if user is active. Otherwise False
     * @summary Is User Active
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersIsUserActive(login: string, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersIsUserActive(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
     * @summary Setactive User
     * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whocanimanage
     * @param {string} privilegeCandidate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersWhoCanIManage(privilegeCandidate: string, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersWhoCanIManage(privilegeCandidate, options).then((request) => request(this.axios, this.basePath));
    }
}


