/* tslint:disable */
/* eslint-disable */
/**
 * UsersManager
 * Scribe user management
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKey
 */
export interface APIKey {
    /**
     * 
     * @type {string}
     * @memberof APIKey
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof APIKey
     */
    description: string;
}
/**
 * 
 * @export
 * @interface APIKeyRequest
 */
export interface APIKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof APIKeyRequest
     */
    key: string;
}
/**
 * 
 * @export
 * @interface APIKeysResponse
 */
export interface APIKeysResponse {
    /**
     * 
     * @type {Array<APIKey>}
     * @memberof APIKeysResponse
     */
    apikeys: Array<APIKey>;
}
/**
 * 
 * @export
 * @interface BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
 */
export interface BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch {
    /**
     * 
     * @type {string}
     * @memberof BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
     */
    privilegeName: string;
    /**
     * 
     * @type {string}
     * @memberof BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
 */
export interface BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyChangePasswordApiV1UsersChangePasswordPatch
 */
export interface BodyChangePasswordApiV1UsersChangePasswordPatch {
    /**
     * Password that user already has.
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    old_password: string;
    /**
     * New password
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    new_password: string;
    /**
     * Target user.
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    login: string;
}
/**
 * 
 * @export
 * @interface BodyCreateUserApiV1UsersUserPost
 */
export interface BodyCreateUserApiV1UsersUserPost {
    /**
     * Login that will be used to identify user.
     * @type {string}
     * @memberof BodyCreateUserApiV1UsersUserPost
     */
    login: string;
    /**
     * Secret password that will be used for log in.
     * @type {string}
     * @memberof BodyCreateUserApiV1UsersUserPost
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete
 */
export interface BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete {
    /**
     * 
     * @type {string}
     * @memberof BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete
     */
    privilegeName: string;
}
/**
 * 
 * @export
 * @interface BodyDeleteRoleApiV1AccessrightsRolesRoleDelete
 */
export interface BodyDeleteRoleApiV1AccessrightsRolesRoleDelete {
    /**
     * 
     * @type {string}
     * @memberof BodyDeleteRoleApiV1AccessrightsRolesRoleDelete
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
 */
export interface BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch {
    /**
     * 
     * @type {string}
     * @memberof BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
     */
    privilegeName: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
 */
export interface BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyResetPasswordApiV1UsersResetPasswordPatch
 */
export interface BodyResetPasswordApiV1UsersResetPasswordPatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyResetPasswordApiV1UsersResetPasswordPatch
     */
    login: string;
}
/**
 * 
 * @export
 * @interface BodySetActiveUserApiV1UsersSetActivePatch
 */
export interface BodySetActiveUserApiV1UsersSetActivePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodySetActiveUserApiV1UsersSetActivePatch
     */
    login: string;
    /**
     * Activate or deactivate user.
     * @type {boolean}
     * @memberof BodySetActiveUserApiV1UsersSetActivePatch
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Password
 */
export interface Password {
    /**
     * 
     * @type {string}
     * @memberof Password
     */
    password: string;
}
/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Privileges
 */
export interface Privileges {
    /**
     * 
     * @type {Array<Privilege>}
     * @memberof Privileges
     */
    privileges: Array<Privilege>;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * 
     * @type {Array<Role>}
     * @memberof Roles
     */
    roles: Array<Role>;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Token
     */
    requiredScopes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type?: string;
}
/**
 * 
 * @export
 * @interface TokenStatus
 */
export interface TokenStatus {
    /**
     * 
     * @type {boolean}
     * @memberof TokenStatus
     */
    valid: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TokenStatus
     */
    scopesValid: boolean;
}
/**
 * 
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
    /**
     * 
     * @type {boolean}
     * @memberof UserStatus
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof UsersResponse
     */
    users?: Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * APIKeysApi - axios parameter creator
 * @export
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiV1AuthApikeysCreateApiKey', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiV1AuthApikeysCreateApiKey', 'password', password)
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (apikeyDescription !== undefined) { 
                localVarFormParams.set('apikey_description', apikeyDescription as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey: async (aPIKeyRequest: APIKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyRequest' is not null or undefined
            assertParamExists('apiV1AuthApikeysDeleteApiKey', 'aPIKeyRequest', aPIKeyRequest)
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/auth/apikeys/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysGetApiKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthApikeysGetApiKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys(options?: any): AxiosPromise<APIKeysResponse> {
            return localVarFp.apiV1AuthApikeysGetApiKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
     * @summary Create Api Key
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [apikeyDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any) {
        return APIKeysApiFp(this.configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {APIKeyRequest} aPIKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiV1AuthApikeysGetApiKeys(options?: any) {
        return APIKeysApiFp(this.configuration).apiV1AuthApikeysGetApiKeys(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRightsApi - axios parameter creator
 * @export
 */
export const AccessRightsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignPrivilege: async (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingAssignPrivilege', 'bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch', bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/assignPrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignRole: async (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingAssignRole', 'bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch', bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/assignRole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemovePrivilege: async (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingRemovePrivilege', 'bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch', bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/removePrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemoveRole: async (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingRemoveRole', 'bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch', bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/removeRole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserHasRoles: async (roles: Array<string>, login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roles' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingUserHasRoles', 'roles', roles)
            // verify required parameter 'login' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingUserHasRoles', 'login', login)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userHasRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserPrivileges: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingUserPrivileges', 'login', login)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userprivileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserRoles: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingUserRoles', 'login', login)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUsersWithRoles: async (roles: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roles' is not null or undefined
            assertParamExists('apiV1AccessrightsManagingUsersWithRoles', 'roles', roles)
            const localVarPath = `/usermanager/api/v1/accessrights/managing/usersWithRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesCreatePrivilege: async (privilege: Privilege, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilege' is not null or undefined
            assertParamExists('apiV1AccessrightsPrivilegesCreatePrivilege', 'privilege', privilege)
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/privilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(privilege, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesDeletePrivilege: async (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete' is not null or undefined
            assertParamExists('apiV1AccessrightsPrivilegesDeletePrivilege', 'bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete', bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete)
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/privilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesGetAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesUserHasPrivilege: async (privileges?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/hasPrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (privileges) {
                localVarQueryParameter['privileges'] = privileges;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesCreateRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('apiV1AccessrightsRolesCreateRole', 'role', role)
            const localVarPath = `/usermanager/api/v1/accessrights/roles/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesDeleteRole: async (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteRoleApiV1AccessrightsRolesRoleDelete' is not null or undefined
            assertParamExists('apiV1AccessrightsRolesDeleteRole', 'bodyDeleteRoleApiV1AccessrightsRolesRoleDelete', bodyDeleteRoleApiV1AccessrightsRolesRoleDelete)
            const localVarPath = `/usermanager/api/v1/accessrights/roles/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesGetRolePrivileges: async (roleName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('apiV1AccessrightsRolesGetRolePrivileges', 'roleName', roleName)
            const localVarPath = `/usermanager/api/v1/accessrights/roles/rolePrivileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/roles/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRightsApi - functional programming interface
 * @export
 */
export const AccessRightsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRightsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUserHasRoles(roles: Array<string>, login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingUserHasRoles(roles, login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUserPrivileges(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingUserPrivileges(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUserRoles(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingUserRoles(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsManagingUsersWithRoles(roles: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsManagingUsersWithRoles(roles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesCreatePrivilege(privilege: Privilege, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsPrivilegesCreatePrivilege(privilege, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesGetAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsPrivilegesGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsPrivilegesUserHasPrivilege(privileges?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsPrivilegesUserHasPrivilege(privileges, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesCreateRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsRolesCreateRole(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesGetRolePrivileges(roleName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsRolesGetRolePrivileges(roleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessrightsRolesRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccessrightsRolesRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRightsApi - factory interface
 * @export
 */
export const AccessRightsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRightsApiFp(configuration)
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserHasRoles(roles: Array<string>, login: string, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsManagingUserHasRoles(roles, login, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserPrivileges(login: string, options?: any): AxiosPromise<Privileges> {
            return localVarFp.apiV1AccessrightsManagingUserPrivileges(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUserRoles(login: string, options?: any): AxiosPromise<Roles> {
            return localVarFp.apiV1AccessrightsManagingUserRoles(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsManagingUsersWithRoles(roles: Array<string>, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsManagingUsersWithRoles(roles, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesCreatePrivilege(privilege: Privilege, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsPrivilegesCreatePrivilege(privilege, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesGetAll(options?: any): AxiosPromise<Privileges> {
            return localVarFp.apiV1AccessrightsPrivilegesGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsPrivilegesUserHasPrivilege(privileges?: Array<string>, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsPrivilegesUserHasPrivilege(privileges, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesCreateRole(role: Role, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsRolesCreateRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesGetRolePrivileges(roleName: string, options?: any): AxiosPromise<Privileges> {
            return localVarFp.apiV1AccessrightsRolesGetRolePrivileges(roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessrightsRolesRoles(options?: any): AxiosPromise<Roles> {
            return localVarFp.apiV1AccessrightsRolesRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessRightsApi - object-oriented interface
 * @export
 * @class AccessRightsApi
 * @extends {BaseAPI}
 */
export class AccessRightsApi extends BaseAPI {
    /**
     * Assigns privilege to the role
     * @summary Assign Privilege
     * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingAssignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign Role
     * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingAssignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes privilege from the role
     * @summary Remove Privilege
     * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingRemovePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes role from the user
     * @summary Remove Role
     * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingRemoveRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if user has specified roles
     * @summary User Has Roles
     * @param {Array<string>} roles 
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUserHasRoles(roles: Array<string>, login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUserHasRoles(roles, login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves list of all user privileges.
     * @summary User Privileges
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUserPrivileges(login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUserPrivileges(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the roles for specified user
     * @summary User Roles
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUserRoles(login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUserRoles(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users with specified roles
     * @summary Users With Roles
     * @param {Array<string>} roles 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsManagingUsersWithRoles(roles: Array<string>, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsManagingUsersWithRoles(roles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new privilege.
     * @summary Create Privilege
     * @param {Privilege} privilege 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesCreatePrivilege(privilege: Privilege, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesCreatePrivilege(privilege, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Privilege
     * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesDeletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of all possible privileges
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesGetAll(options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Has Privilege
     * @param {Array<string>} [privileges] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsPrivilegesUserHasPrivilege(privileges?: Array<string>, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsPrivilegesUserHasPrivilege(privileges, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new role
     * @summary Create Role
     * @param {Role} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesCreateRole(role: Role, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesCreateRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes role
     * @summary Delete Role
     * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesDeleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all privileges assigned to specified role
     * @summary Get Role Privileges
     * @param {string} roleName Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesGetRolePrivileges(roleName: string, options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesGetRolePrivileges(roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all existed roles
     * @summary Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public apiV1AccessrightsRolesRoles(options?: any) {
        return AccessRightsApiFp(this.configuration).apiV1AccessrightsRolesRoles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiV1AuthApikeysCreateApiKey', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiV1AuthApikeysCreateApiKey', 'password', password)
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (apikeyDescription !== undefined) { 
                localVarFormParams.set('apikey_description', apikeyDescription as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey: async (aPIKeyRequest: APIKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyRequest' is not null or undefined
            assertParamExists('apiV1AuthApikeysDeleteApiKey', 'aPIKeyRequest', aPIKeyRequest)
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/auth/apikeys/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthIsTokenValid: async (token: Token, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('apiV1AuthIsTokenValid', 'token', token)
            const localVarPath = `/usermanager/api/v1/auth/checkToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(token, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLoginForAccessToken: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiV1AuthLoginForAccessToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiV1AuthLoginForAccessToken', 'password', password)
            const localVarPath = `/usermanager/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthApikeysGetApiKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthApikeysGetApiKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthIsTokenValid(token: Token, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthIsTokenValid(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLoginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthLoginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthApikeysGetApiKeys(options?: any): AxiosPromise<APIKeysResponse> {
            return localVarFp.apiV1AuthApikeysGetApiKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthIsTokenValid(token: Token, options?: any): AxiosPromise<TokenStatus> {
            return localVarFp.apiV1AuthIsTokenValid(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLoginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.apiV1AuthLoginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
     * @summary Create Api Key
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [apikeyDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthApikeysCreateApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthApikeysCreateApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {APIKeyRequest} aPIKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthApikeysDeleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthApikeysDeleteApiKey(aPIKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthApikeysGetApiKeys(options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthApikeysGetApiKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Token Valid
     * @param {Token} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthIsTokenValid(token: Token, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthIsTokenValid(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiV1AuthLoginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return AuthApiFp(this.configuration).apiV1AuthLoginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCanIManage: async (privilegeCandidate: string, userId?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilegeCandidate' is not null or undefined
            assertParamExists('apiV1UsersCanIManage', 'privilegeCandidate', privilegeCandidate)
            const localVarPath = `/usermanager/api/v1/users/canIManage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (privilegeCandidate !== undefined) {
                localVarQueryParameter['privilegeCandidate'] = privilegeCandidate;
            }

            if (userId) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePassword: async (bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyChangePasswordApiV1UsersChangePasswordPatch' is not null or undefined
            assertParamExists('apiV1UsersChangePassword', 'bodyChangePasswordApiV1UsersChangePasswordPatch', bodyChangePasswordApiV1UsersChangePasswordPatch)
            const localVarPath = `/usermanager/api/v1/users/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyChangePasswordApiV1UsersChangePasswordPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCreateUser: async (bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserApiV1UsersUserPost' is not null or undefined
            assertParamExists('apiV1UsersCreateUser', 'bodyCreateUserApiV1UsersUserPost', bodyCreateUserApiV1UsersUserPost)
            const localVarPath = `/usermanager/api/v1/users/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateUserApiV1UsersUserPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersGetUser: async (userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/users/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }

            if (loginSubstring !== undefined) {
                localVarQueryParameter['login_substring'] = loginSubstring;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIsUserActive: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('apiV1UsersIsUserActive', 'login', login)
            const localVarPath = `/usermanager/api/v1/users/isActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersResetPassword: async (bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetPasswordApiV1UsersResetPasswordPatch' is not null or undefined
            assertParamExists('apiV1UsersResetPassword', 'bodyResetPasswordApiV1UsersResetPasswordPatch', bodyResetPasswordApiV1UsersResetPasswordPatch)
            const localVarPath = `/usermanager/api/v1/users/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyResetPasswordApiV1UsersResetPasswordPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSetActiveUser: async (bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetActiveUserApiV1UsersSetActivePatch' is not null or undefined
            assertParamExists('apiV1UsersSetActiveUser', 'bodySetActiveUserApiV1UsersSetActivePatch', bodySetActiveUserApiV1UsersSetActivePatch)
            const localVarPath = `/usermanager/api/v1/users/setActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodySetActiveUserApiV1UsersSetActivePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {string} [specificRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersWhoCanIManage: async (privilegeCandidate: string, specificRole?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilegeCandidate' is not null or undefined
            assertParamExists('apiV1UsersWhoCanIManage', 'privilegeCandidate', privilegeCandidate)
            const localVarPath = `/usermanager/api/v1/users/whoCanIManage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (privilegeCandidate !== undefined) {
                localVarQueryParameter['privilegeCandidate'] = privilegeCandidate;
            }

            if (specificRole !== undefined) {
                localVarQueryParameter['specificRole'] = specificRole;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersCanIManage(privilegeCandidate: string, userId?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersCanIManage(privilegeCandidate, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Password>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersGetUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersGetUser(userId, login, loginSubstring, role, active, values, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersIsUserActive(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersIsUserActive(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {string} [specificRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersWhoCanIManage(privilegeCandidate: string, specificRole?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersWhoCanIManage(privilegeCandidate, specificRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCanIManage(privilegeCandidate: string, userId?: Array<number>, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1UsersCanIManage(privilegeCandidate, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any): AxiosPromise<Password> {
            return localVarFp.apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersGetUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any): AxiosPromise<UsersResponse> {
            return localVarFp.apiV1UsersGetUser(userId, login, loginSubstring, role, active, values, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIsUserActive(login: string, options?: any): AxiosPromise<UserStatus> {
            return localVarFp.apiV1UsersIsUserActive(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {string} [specificRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersWhoCanIManage(privilegeCandidate: string, specificRole?: string, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1UsersWhoCanIManage(privilegeCandidate, specificRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
     * @summary Canimanage
     * @param {string} privilegeCandidate 
     * @param {Array<number>} [userId] Checks for these users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersCanIManage(privilegeCandidate: string, userId?: Array<number>, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersCanIManage(privilegeCandidate, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user password to new one
     * @summary Change Password
     * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersChangePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create User
     * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersCreateUser(bodyCreateUserApiV1UsersUserPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {number} [userId] Get only user with specified id.
     * @param {string} [login] Return user with specified login. Login should match exactly.
     * @param {string} [loginSubstring] Return user that has in login specified substring.
     * @param {string} [role] Return user with specified role. Role should match exactly.
     * @param {boolean} [active] Return users which has provided status.
     * @param {Array<string>} [values] Only return specified fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersGetUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersGetUser(userId, login, loginSubstring, role, active, values, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns True if user is active. Otherwise False
     * @summary Is User Active
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersIsUserActive(login: string, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersIsUserActive(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersResetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
     * @summary Setactive User
     * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersSetActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whocanimanage
     * @param {string} privilegeCandidate 
     * @param {string} [specificRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersWhoCanIManage(privilegeCandidate: string, specificRole?: string, options?: any) {
        return UsersApiFp(this.configuration).apiV1UsersWhoCanIManage(privilegeCandidate, specificRole, options).then((request) => request(this.axios, this.basePath));
    }
}


