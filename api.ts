/* tslint:disable */
/* eslint-disable */
/**
 * UsersManager
 * Scribe user management
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKey
 */
export interface APIKey {
    /**
     * 
     * @type {string}
     * @memberof APIKey
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof APIKey
     */
    description: string;
}
/**
 * 
 * @export
 * @interface APIKeyRequest
 */
export interface APIKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof APIKeyRequest
     */
    key: string;
}
/**
 * 
 * @export
 * @interface APIKeysResponse
 */
export interface APIKeysResponse {
    /**
     * 
     * @type {Array<APIKey>}
     * @memberof APIKeysResponse
     */
    apikeys: Array<APIKey>;
}
/**
 * 
 * @export
 * @interface BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
 */
export interface BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch {
    /**
     * 
     * @type {string}
     * @memberof BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
     */
    privilegeName: string;
    /**
     * 
     * @type {string}
     * @memberof BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
 */
export interface BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyChangePasswordApiV1UsersChangePasswordPatch
 */
export interface BodyChangePasswordApiV1UsersChangePasswordPatch {
    /**
     * Password that user already has.
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    old_password: string;
    /**
     * New password
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    new_password: string;
    /**
     * Target user.
     * @type {string}
     * @memberof BodyChangePasswordApiV1UsersChangePasswordPatch
     */
    login: string;
}
/**
 * 
 * @export
 * @interface BodyCreateApiKeyApiV1AuthApikeysApikeyPost
 */
export interface BodyCreateApiKeyApiV1AuthApikeysApikeyPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    grant_type?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    client_secret?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateApiKeyApiV1AuthApikeysApikeyPost
     */
    apikey_description?: string;
}
/**
 * 
 * @export
 * @interface BodyCreateUserApiV1UsersUserPost
 */
export interface BodyCreateUserApiV1UsersUserPost {
    /**
     * Login that will be used to identify user.
     * @type {string}
     * @memberof BodyCreateUserApiV1UsersUserPost
     */
    login: string;
    /**
     * Secret password that will be used for log in.
     * @type {string}
     * @memberof BodyCreateUserApiV1UsersUserPost
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete
 */
export interface BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete {
    /**
     * 
     * @type {string}
     * @memberof BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete
     */
    privilegeName: string;
}
/**
 * 
 * @export
 * @interface BodyDeleteRoleApiV1AccessrightsRolesRoleDelete
 */
export interface BodyDeleteRoleApiV1AccessrightsRolesRoleDelete {
    /**
     * 
     * @type {string}
     * @memberof BodyDeleteRoleApiV1AccessrightsRolesRoleDelete
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyLoginForAccessTokenApiV1AuthTokenPost
 */
export interface BodyLoginForAccessTokenApiV1AuthTokenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    grant_type?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginForAccessTokenApiV1AuthTokenPost
     */
    client_secret?: string;
}
/**
 * 
 * @export
 * @interface BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
 */
export interface BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch {
    /**
     * 
     * @type {string}
     * @memberof BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
     */
    privilegeName: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
 */
export interface BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch
     */
    roleName: string;
}
/**
 * 
 * @export
 * @interface BodyResetPasswordApiV1UsersResetPasswordPatch
 */
export interface BodyResetPasswordApiV1UsersResetPasswordPatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodyResetPasswordApiV1UsersResetPasswordPatch
     */
    login: string;
}
/**
 * 
 * @export
 * @interface BodySetActiveUserApiV1UsersSetActivePatch
 */
export interface BodySetActiveUserApiV1UsersSetActivePatch {
    /**
     * Target user.
     * @type {string}
     * @memberof BodySetActiveUserApiV1UsersSetActivePatch
     */
    login: string;
    /**
     * Activate or deactivate user.
     * @type {boolean}
     * @memberof BodySetActiveUserApiV1UsersSetActivePatch
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Password
 */
export interface Password {
    /**
     * 
     * @type {string}
     * @memberof Password
     */
    password: string;
}
/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Privileges
 */
export interface Privileges {
    /**
     * 
     * @type {Array<Privilege>}
     * @memberof Privileges
     */
    privileges: Array<Privilege>;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * 
     * @type {Array<Role>}
     * @memberof Roles
     */
    roles: Array<Role>;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Token
     */
    requiredScopes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type?: string;
}
/**
 * 
 * @export
 * @interface TokenStatus
 */
export interface TokenStatus {
    /**
     * 
     * @type {boolean}
     * @memberof TokenStatus
     */
    valid: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TokenStatus
     */
    scopesValid: boolean;
}
/**
 * 
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
    /**
     * 
     * @type {boolean}
     * @memberof UserStatus
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof UsersResponse
     */
    users?: Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * APIKeysApi - axios parameter creator
 * @export
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling createApiKey.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (apikeyDescription !== undefined) { 
                localVarFormParams.set('apikey_description', apikeyDescription as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (aPIKeyRequest: APIKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyRequest' is not null or undefined
            if (aPIKeyRequest === null || aPIKeyRequest === undefined) {
                throw new RequiredError('aPIKeyRequest','Required parameter aPIKeyRequest was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aPIKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aPIKeyRequest !== undefined ? aPIKeyRequest : {}) : (aPIKeyRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/auth/apikeys/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await APIKeysApiAxiosParamCreator(configuration).createApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await APIKeysApiAxiosParamCreator(configuration).deleteApiKey(aPIKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeysResponse>> {
            const localVarAxiosArgs = await APIKeysApiAxiosParamCreator(configuration).getApiKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): AxiosPromise<Token> {
            return APIKeysApiFp(configuration).createApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): AxiosPromise<Token> {
            return APIKeysApiFp(configuration).deleteApiKey(aPIKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: any): AxiosPromise<APIKeysResponse> {
            return APIKeysApiFp(configuration).getApiKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
     * @summary Create Api Key
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [apikeyDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public createApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any) {
        return APIKeysApiFp(this.configuration).createApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {APIKeyRequest} aPIKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public deleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).deleteApiKey(aPIKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public getApiKeys(options?: any) {
        return APIKeysApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRightsApi - axios parameter creator
 * @export
 */
export const AccessRightsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPrivilege: async (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch' is not null or undefined
            if (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch === null || bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch === undefined) {
                throw new RequiredError('bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch','Required parameter bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch was null or undefined when calling assignPrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/assignPrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch !== undefined ? bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch : {}) : (bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole: async (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch' is not null or undefined
            if (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch === null || bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch === undefined) {
                throw new RequiredError('bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch','Required parameter bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch was null or undefined when calling assignRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/assignRole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch !== undefined ? bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch : {}) : (bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrivilege: async (privilege: Privilege, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilege' is not null or undefined
            if (privilege === null || privilege === undefined) {
                throw new RequiredError('privilege','Required parameter privilege was null or undefined when calling createPrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/privilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof privilege !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(privilege !== undefined ? privilege : {}) : (privilege || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling createRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/roles/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof role !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(role !== undefined ? role : {}) : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrivilege: async (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete' is not null or undefined
            if (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete === null || bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete === undefined) {
                throw new RequiredError('bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete','Required parameter bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete was null or undefined when calling deletePrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/privilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete !== undefined ? bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete : {}) : (bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteRoleApiV1AccessrightsRolesRoleDelete' is not null or undefined
            if (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete === null || bodyDeleteRoleApiV1AccessrightsRolesRoleDelete === undefined) {
                throw new RequiredError('bodyDeleteRoleApiV1AccessrightsRolesRoleDelete','Required parameter bodyDeleteRoleApiV1AccessrightsRolesRoleDelete was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/roles/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteRoleApiV1AccessrightsRolesRoleDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete !== undefined ? bodyDeleteRoleApiV1AccessrightsRolesRoleDelete : {}) : (bodyDeleteRoleApiV1AccessrightsRolesRoleDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolePrivileges: async (roleName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling getRolePrivileges.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/roles/rolePrivileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePrivilege: async (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch' is not null or undefined
            if (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch === null || bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch === undefined) {
                throw new RequiredError('bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch','Required parameter bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch was null or undefined when calling removePrivilege.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/removePrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch !== undefined ? bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch : {}) : (bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRole: async (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch' is not null or undefined
            if (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch === null || bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch === undefined) {
                throw new RequiredError('bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch','Required parameter bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch was null or undefined when calling removeRole.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/removeRole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch !== undefined ? bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch : {}) : (bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/roles/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasPrivilege: async (privileges?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/accessrights/privileges/hasPrivilege`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (privileges) {
                localVarQueryParameter['privileges'] = privileges;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasRoles: async (roles: Array<string>, login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling userHasRoles.');
            }
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling userHasRoles.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userHasRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrivileges: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling userPrivileges.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userprivileges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRoles: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling userRoles.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/userRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersWithRoles: async (roles: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling usersWithRoles.');
            }
            const localVarPath = `/usermanager/api/v1/accessrights/managing/usersWithRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRightsApi - functional programming interface
 * @export
 */
export const AccessRightsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).assignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).assignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrivilege(privilege: Privilege, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).createPrivilege(privilege, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).createRole(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).deletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).deleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).getAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolePrivileges(roleName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).getRolePrivileges(roleName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).removePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).removeRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).roles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userHasPrivilege(privileges?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).userHasPrivilege(privileges, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userHasRoles(roles: Array<string>, login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).userHasRoles(roles, login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPrivileges(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Privileges>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).userPrivileges(login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRoles(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).userRoles(login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersWithRoles(roles: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AccessRightsApiAxiosParamCreator(configuration).usersWithRoles(roles, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessRightsApi - factory interface
 * @export
 */
export const AccessRightsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Assigns privilege to the role
         * @summary Assign Privilege
         * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).assignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign Role
         * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).assignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new privilege.
         * @summary Create Privilege
         * @param {Privilege} privilege 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrivilege(privilege: Privilege, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).createPrivilege(privilege, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new role
         * @summary Create Role
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(role: Role, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).createRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Privilege
         * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).deletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes role
         * @summary Delete Role
         * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).deleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of all possible privileges
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any): AxiosPromise<Privileges> {
            return AccessRightsApiFp(configuration).getAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all privileges assigned to specified role
         * @summary Get Role Privileges
         * @param {string} roleName Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolePrivileges(roleName: string, options?: any): AxiosPromise<Privileges> {
            return AccessRightsApiFp(configuration).getRolePrivileges(roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes privilege from the role
         * @summary Remove Privilege
         * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).removePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes role from the user
         * @summary Remove Role
         * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).removeRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all existed roles
         * @summary Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roles(options?: any): AxiosPromise<Roles> {
            return AccessRightsApiFp(configuration).roles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Has Privilege
         * @param {Array<string>} [privileges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasPrivilege(privileges?: Array<string>, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).userHasPrivilege(privileges, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if user has specified roles
         * @summary User Has Roles
         * @param {Array<string>} roles 
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasRoles(roles: Array<string>, login: string, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).userHasRoles(roles, login, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves list of all user privileges.
         * @summary User Privileges
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrivileges(login: string, options?: any): AxiosPromise<Privileges> {
            return AccessRightsApiFp(configuration).userPrivileges(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the roles for specified user
         * @summary User Roles
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRoles(login: string, options?: any): AxiosPromise<Roles> {
            return AccessRightsApiFp(configuration).userRoles(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users with specified roles
         * @summary Users With Roles
         * @param {Array<string>} roles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersWithRoles(roles: Array<string>, options?: any): AxiosPromise<any> {
            return AccessRightsApiFp(configuration).usersWithRoles(roles, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessRightsApi - object-oriented interface
 * @export
 * @class AccessRightsApi
 * @extends {BaseAPI}
 */
export class AccessRightsApi extends BaseAPI {
    /**
     * Assigns privilege to the role
     * @summary Assign Privilege
     * @param {BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch} bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public assignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch: BodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).assignPrivilege(bodyAssignPrivilegeApiV1AccessrightsManagingAssignPrivilegePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign Role
     * @param {BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch} bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public assignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch: BodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).assignRole(bodyAssignRoleApiV1AccessrightsManagingAssignRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new privilege.
     * @summary Create Privilege
     * @param {Privilege} privilege 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public createPrivilege(privilege: Privilege, options?: any) {
        return AccessRightsApiFp(this.configuration).createPrivilege(privilege, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new role
     * @summary Create Role
     * @param {Role} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public createRole(role: Role, options?: any) {
        return AccessRightsApiFp(this.configuration).createRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Privilege
     * @param {BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete} bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public deletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete: BodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options?: any) {
        return AccessRightsApiFp(this.configuration).deletePrivilege(bodyDeletePrivilegeApiV1AccessrightsPrivilegesPrivilegeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes role
     * @summary Delete Role
     * @param {BodyDeleteRoleApiV1AccessrightsRolesRoleDelete} bodyDeleteRoleApiV1AccessrightsRolesRoleDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public deleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete: BodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options?: any) {
        return AccessRightsApiFp(this.configuration).deleteRole(bodyDeleteRoleApiV1AccessrightsRolesRoleDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of all possible privileges
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public getAll(options?: any) {
        return AccessRightsApiFp(this.configuration).getAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all privileges assigned to specified role
     * @summary Get Role Privileges
     * @param {string} roleName Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public getRolePrivileges(roleName: string, options?: any) {
        return AccessRightsApiFp(this.configuration).getRolePrivileges(roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes privilege from the role
     * @summary Remove Privilege
     * @param {BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch} bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public removePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch: BodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).removePrivilege(bodyRemovePrivilegeApiV1AccessrightsManagingRemovePrivilegePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes role from the user
     * @summary Remove Role
     * @param {BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch} bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public removeRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch: BodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options?: any) {
        return AccessRightsApiFp(this.configuration).removeRole(bodyRemoveRoleApiV1AccessrightsManagingRemoveRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all existed roles
     * @summary Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public roles(options?: any) {
        return AccessRightsApiFp(this.configuration).roles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Has Privilege
     * @param {Array<string>} [privileges] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public userHasPrivilege(privileges?: Array<string>, options?: any) {
        return AccessRightsApiFp(this.configuration).userHasPrivilege(privileges, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if user has specified roles
     * @summary User Has Roles
     * @param {Array<string>} roles 
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public userHasRoles(roles: Array<string>, login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).userHasRoles(roles, login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves list of all user privileges.
     * @summary User Privileges
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public userPrivileges(login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).userPrivileges(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the roles for specified user
     * @summary User Roles
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public userRoles(login: string, options?: any) {
        return AccessRightsApiFp(this.configuration).userRoles(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users with specified roles
     * @summary Users With Roles
     * @param {Array<string>} roles 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRightsApi
     */
    public usersWithRoles(roles: Array<string>, options?: any) {
        return AccessRightsApiFp(this.configuration).usersWithRoles(roles, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling createApiKey.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (apikeyDescription !== undefined) { 
                localVarFormParams.set('apikey_description', apikeyDescription as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (aPIKeyRequest: APIKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyRequest' is not null or undefined
            if (aPIKeyRequest === null || aPIKeyRequest === undefined) {
                throw new RequiredError('aPIKeyRequest','Required parameter aPIKeyRequest was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/usermanager/api/v1/auth/apikeys/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aPIKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aPIKeyRequest !== undefined ? aPIKeyRequest : {}) : (aPIKeyRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/auth/apikeys/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isTokenValid: async (token: Token, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling isTokenValid.');
            }
            const localVarPath = `/usermanager/api/v1/auth/checkToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof token !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(token !== undefined ? token : {}) : (token || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessToken: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling loginForAccessToken.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginForAccessToken.');
            }
            const localVarPath = `/usermanager/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).createApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).deleteApiKey(aPIKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeysResponse>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).getApiKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isTokenValid(token: Token, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenStatus>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).isTokenValid(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).loginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
         * @summary Create Api Key
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {string} [apikeyDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any): AxiosPromise<Token> {
            return AuthApiFp(configuration).createApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {APIKeyRequest} aPIKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any): AxiosPromise<Token> {
            return AuthApiFp(configuration).deleteApiKey(aPIKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: any): AxiosPromise<APIKeysResponse> {
            return AuthApiFp(configuration).getApiKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Token Valid
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isTokenValid(token: Token, options?: any): AxiosPromise<TokenStatus> {
            return AuthApiFp(configuration).isTokenValid(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return AuthApiFp(configuration).loginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Creates key similar to access token, but without expire time. This key will be stored at server and can be revoked at any moment.
     * @summary Create Api Key
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [apikeyDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createApiKey(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, apikeyDescription?: string, options?: any) {
        return AuthApiFp(this.configuration).createApiKey(username, password, grantType, scope, clientId, clientSecret, apikeyDescription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {APIKeyRequest} aPIKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteApiKey(aPIKeyRequest: APIKeyRequest, options?: any) {
        return AuthApiFp(this.configuration).deleteApiKey(aPIKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getApiKeys(options?: any) {
        return AuthApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Token Valid
     * @param {Token} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public isTokenValid(token: Token, options?: any) {
        return AuthApiFp(this.configuration).isTokenValid(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to create access token.  Use scopes for definig access privileges. If no scopes defined -  token with all possible scopes for current user will be generated. If you just want empty token - add global_empty scope.
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginForAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return AuthApiFp(this.configuration).loginForAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canIManage: async (privilegeCandidate: string, userId?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilegeCandidate' is not null or undefined
            if (privilegeCandidate === null || privilegeCandidate === undefined) {
                throw new RequiredError('privilegeCandidate','Required parameter privilegeCandidate was null or undefined when calling canIManage.');
            }
            const localVarPath = `/usermanager/api/v1/users/canIManage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (privilegeCandidate !== undefined) {
                localVarQueryParameter['privilegeCandidate'] = privilegeCandidate;
            }

            if (userId) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyChangePasswordApiV1UsersChangePasswordPatch' is not null or undefined
            if (bodyChangePasswordApiV1UsersChangePasswordPatch === null || bodyChangePasswordApiV1UsersChangePasswordPatch === undefined) {
                throw new RequiredError('bodyChangePasswordApiV1UsersChangePasswordPatch','Required parameter bodyChangePasswordApiV1UsersChangePasswordPatch was null or undefined when calling changePassword.');
            }
            const localVarPath = `/usermanager/api/v1/users/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyChangePasswordApiV1UsersChangePasswordPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyChangePasswordApiV1UsersChangePasswordPatch !== undefined ? bodyChangePasswordApiV1UsersChangePasswordPatch : {}) : (bodyChangePasswordApiV1UsersChangePasswordPatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserApiV1UsersUserPost' is not null or undefined
            if (bodyCreateUserApiV1UsersUserPost === null || bodyCreateUserApiV1UsersUserPost === undefined) {
                throw new RequiredError('bodyCreateUserApiV1UsersUserPost','Required parameter bodyCreateUserApiV1UsersUserPost was null or undefined when calling createUser.');
            }
            const localVarPath = `/usermanager/api/v1/users/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateUserApiV1UsersUserPost !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateUserApiV1UsersUserPost !== undefined ? bodyCreateUserApiV1UsersUserPost : {}) : (bodyCreateUserApiV1UsersUserPost || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usermanager/api/v1/users/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }

            if (loginSubstring !== undefined) {
                localVarQueryParameter['login_substring'] = loginSubstring;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserActive: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling isUserActive.');
            }
            const localVarPath = `/usermanager/api/v1/users/isActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetPasswordApiV1UsersResetPasswordPatch' is not null or undefined
            if (bodyResetPasswordApiV1UsersResetPasswordPatch === null || bodyResetPasswordApiV1UsersResetPasswordPatch === undefined) {
                throw new RequiredError('bodyResetPasswordApiV1UsersResetPasswordPatch','Required parameter bodyResetPasswordApiV1UsersResetPasswordPatch was null or undefined when calling resetPassword.');
            }
            const localVarPath = `/usermanager/api/v1/users/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyResetPasswordApiV1UsersResetPasswordPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyResetPasswordApiV1UsersResetPasswordPatch !== undefined ? bodyResetPasswordApiV1UsersResetPasswordPatch : {}) : (bodyResetPasswordApiV1UsersResetPasswordPatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveUser: async (bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetActiveUserApiV1UsersSetActivePatch' is not null or undefined
            if (bodySetActiveUserApiV1UsersSetActivePatch === null || bodySetActiveUserApiV1UsersSetActivePatch === undefined) {
                throw new RequiredError('bodySetActiveUserApiV1UsersSetActivePatch','Required parameter bodySetActiveUserApiV1UsersSetActivePatch was null or undefined when calling setActiveUser.');
            }
            const localVarPath = `/usermanager/api/v1/users/setActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodySetActiveUserApiV1UsersSetActivePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodySetActiveUserApiV1UsersSetActivePatch !== undefined ? bodySetActiveUserApiV1UsersSetActivePatch : {}) : (bodySetActiveUserApiV1UsersSetActivePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoCanIManage: async (privilegeCandidate: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'privilegeCandidate' is not null or undefined
            if (privilegeCandidate === null || privilegeCandidate === undefined) {
                throw new RequiredError('privilegeCandidate','Required parameter privilegeCandidate was null or undefined when calling whoCanIManage.');
            }
            const localVarPath = `/usermanager/api/v1/users/whoCanIManage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (privilegeCandidate !== undefined) {
                localVarQueryParameter['privilegeCandidate'] = privilegeCandidate;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canIManage(privilegeCandidate: string, userId?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).canIManage(privilegeCandidate, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Password>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).changePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).createUser(bodyCreateUserApiV1UsersUserPost, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUser(userId, login, loginSubstring, role, active, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserActive(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStatus>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).isUserActive(login, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).resetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).setActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoCanIManage(privilegeCandidate: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).whoCanIManage(privilegeCandidate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
         * @summary Canimanage
         * @param {string} privilegeCandidate 
         * @param {Array<number>} [userId] Checks for these users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canIManage(privilegeCandidate: string, userId?: Array<number>, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).canIManage(privilegeCandidate, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user password to new one
         * @summary Change Password
         * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any): AxiosPromise<Password> {
            return UsersApiFp(configuration).changePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create User
         * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).createUser(bodyCreateUserApiV1UsersUserPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {number} [userId] Get only user with specified id.
         * @param {string} [login] Return user with specified login. Login should match exactly.
         * @param {string} [loginSubstring] Return user that has in login specified substring.
         * @param {string} [role] Return user with specified role. Role should match exactly.
         * @param {boolean} [active] Return users which has provided status.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any): AxiosPromise<UsersResponse> {
            return UsersApiFp(configuration).getUser(userId, login, loginSubstring, role, active, values, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns True if user is active. Otherwise False
         * @summary Is User Active
         * @param {string} login Target user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserActive(login: string, options?: any): AxiosPromise<UserStatus> {
            return UsersApiFp(configuration).isUserActive(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).resetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
         * @summary Setactive User
         * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).setActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whocanimanage
         * @param {string} privilegeCandidate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoCanIManage(privilegeCandidate: string, options?: any): AxiosPromise<any> {
            return UsersApiFp(configuration).whoCanIManage(privilegeCandidate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Checks if user can manage listed user with provided privilege candidate. Returns list of user that he can manage
     * @summary Canimanage
     * @param {string} privilegeCandidate 
     * @param {Array<number>} [userId] Checks for these users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public canIManage(privilegeCandidate: string, userId?: Array<number>, options?: any) {
        return UsersApiFp(this.configuration).canIManage(privilegeCandidate, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user password to new one
     * @summary Change Password
     * @param {BodyChangePasswordApiV1UsersChangePasswordPatch} bodyChangePasswordApiV1UsersChangePasswordPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changePassword(bodyChangePasswordApiV1UsersChangePasswordPatch: BodyChangePasswordApiV1UsersChangePasswordPatch, options?: any) {
        return UsersApiFp(this.configuration).changePassword(bodyChangePasswordApiV1UsersChangePasswordPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create User
     * @param {BodyCreateUserApiV1UsersUserPost} bodyCreateUserApiV1UsersUserPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(bodyCreateUserApiV1UsersUserPost: BodyCreateUserApiV1UsersUserPost, options?: any) {
        return UsersApiFp(this.configuration).createUser(bodyCreateUserApiV1UsersUserPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {number} [userId] Get only user with specified id.
     * @param {string} [login] Return user with specified login. Login should match exactly.
     * @param {string} [loginSubstring] Return user that has in login specified substring.
     * @param {string} [role] Return user with specified role. Role should match exactly.
     * @param {boolean} [active] Return users which has provided status.
     * @param {Array<string>} [values] Only return specified fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId?: number, login?: string, loginSubstring?: string, role?: string, active?: boolean, values?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, login, loginSubstring, role, active, values, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns True if user is active. Otherwise False
     * @summary Is User Active
     * @param {string} login Target user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public isUserActive(login: string, options?: any) {
        return UsersApiFp(this.configuration).isUserActive(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set user password to random one. Doesnt require to know old password.  Requires additional manage_users privileges.  Requester should be authorized with token that has at least all the target user privileges.
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1UsersResetPasswordPatch} bodyResetPasswordApiV1UsersResetPasswordPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch: BodyResetPasswordApiV1UsersResetPasswordPatch, options?: any) {
        return UsersApiFp(this.configuration).resetPassword(bodyResetPasswordApiV1UsersResetPasswordPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or deactivates user. Deactivated users have no previleges and can do nothing inside system.
     * @summary Setactive User
     * @param {BodySetActiveUserApiV1UsersSetActivePatch} bodySetActiveUserApiV1UsersSetActivePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setActiveUser(bodySetActiveUserApiV1UsersSetActivePatch: BodySetActiveUserApiV1UsersSetActivePatch, options?: any) {
        return UsersApiFp(this.configuration).setActiveUser(bodySetActiveUserApiV1UsersSetActivePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whocanimanage
     * @param {string} privilegeCandidate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public whoCanIManage(privilegeCandidate: string, options?: any) {
        return UsersApiFp(this.configuration).whoCanIManage(privilegeCandidate, options).then((request) => request(this.axios, this.basePath));
    }
}


